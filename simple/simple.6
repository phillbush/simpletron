.TH simple 6
.SH NAME
.B simple
\- compiles SimpleBASIC into Simple Machine Language
.SH SYNOPSIS
.BR simple
.RB [ -O ]
.RB [ -o
.IR outfile ]
.I infile
.SH DESCRIPTION
.B simple
compiles a source code written in a dialect of BASIC known as
SimpleBASIC into a program in Simple Machine Language (SML) ready to be run by
the Simpletron simulator.
.PP
A file containing a SimpleBASIC program is read by the compiler and converted to SML code.
The SML code is output to a file on disk, in which SML instructions appear one per line.
This file is by default
.BR a.out ,
but can be set by the option
.BR -o .
The SML file can then be loaded into the Simpletron simulator.
.PP
The options are as follows:
.TP
.B -O
Optimize the compilation.
Makes the compiler do another pass to get rid of redundant instructions.
.TP
.BI "-o " outfile
Put executable program into output file
.IR outfile .
.PP
.SH THE SIMPLEBASIC COMPILATOR
.SS The symbol table
The symbol table is a table that contains each symbol (label or variable)
in the program and its corresponding location in the Simpletron's memory.
For a label, the location is the position in the Simpletron memory where
the SML instruction generated by the SimpleBASIC statement begin.
For a variable, the location is the position in the Simpletron memory
where the variable is stored.
.PP
Each symbol (variable or label) is a single-character identifier.
.SS The SML array
The SML array contains the Simpletron Machine Language (SML)
instructions generated by the SimpleBASIC commands.  An SML instruction
is a four-digit integer that comprises two parts: the operation code
(opcode) and the operand.
.PP
The opcode is determined by commands in
SimpleBASIC. For example, the SimpleBASIC command
.B input
correspond to SML opcode
.B 11
(write).
.PP
The operand is a immediate value or a memory location containing the
data on which the operation code performs its task.  For example, the
opcode
.B 10
(input) reads a value from keyboard and stores it in the memory location
specified by the operand.
The compiler searchs the symbol table to determine the Simpletron memory
location for each symbol so the corresponding location can be used to
complete the SML instructions.
.PP
Generaly, each SimpleBASIC command generates a single SML instruction.
But compilation of
.B if...,gotO
and
.B LET
statements is more complicated than other statements: they are the only
statements that produce more than one SML instruction.
.PP
For an
.B IF...,GOTO
statement, the compiler produces code to test the condition and to
branch to another line if necessary.  The result of the branch could be
an unresolved reference.  Each of the relational and quality operators
can be simulated using SML's branch zero and branch negative instructions
(or possibly a combination of both).
.PP
For a
.B LET
statement, the compiler produces code to evaluate an arbitrarily complex
arithmetic expression consisting of integer variables and/or constants.
When a compiler encounters an expression, it converts the expression
from infix notation to postfix notation, then evaluates the postfix
expression.
.SS The flag array
When a
.B GOTO
statement is compiled with an unresolved reference (ie', it refers to a
location in the code that has not been read yet), the SML instruction
must be flagged to indicate that the second pass of the compiler must
complete the instruction.  The flags are stored in an array of type
.B char
in which each element is initialized to zero.
If the memory location to which a line number in the Simple program
refers is not yet known (ie', it's not in the symbol table), the line
number is stored in the flag array in the element with the same
subscript as the incomplete instruction.
The operand of the incomplete instruction is set to 00 temporarily.
.PP
For example, an unconditional branch instruction (making a forward
reference) is left as
.B +5000
until the resolve pass of the compiler.
.SS Memory size
The Simpletron machine contains only 100 locations of memory, and a SML
program loaded into the Simpletron's machine occupies the whole memory.
Both data and instructions are located in memory.
The beginning of the memory is used to store instructions, while the end of the memory is used to store data.
The position of the memory where the next instruction and data should be
placed is determined by the instruction counter and the the data
counter, respectively.
.SS Counters
It's necessary to keep track of the next instruction location in the SML
array because there is not a one-to-one correspondence between
SimpleBASIC statements and SML instructions.
.PP
Each time an instruction is produced, the instruction counter is
incremented to the next location in the SML array.
.PP
The size of Simpletron's memory could present a problem for Simple
programs with many statements, variables and constants.  It's
conceivable that the compiler will run out of memory.
To test for this case, the program contains a data counter to keep track
of the location at which the next variable or constant will be stored in
the SML array.
.PP
If the value of the instruction counter is larger than the data counter,
the SML array is full.  In this case, the compilation process terminates
and the compiler prints an error message indicating that it ran out of
memory during compilation.
.SS Passes
The compiler performs four passes (five, if optimization is set) to
convert a SimpleBASIC program to SML.
.TP
Initialize
The zeroth pass initializates the compilation variables and arrays.  The
symbol table, the SML array and the flag array are allocated and
initialized.  The compilation counters are zeroed.
.TP
Populate
The first actual pass populate the symbol table with the variable names
and label names from the source code, populate the SML array
with instructions generated by the SimpleBASIC statements, and flag any
instruction that is incomplete and needs another pass to be fully
completed.
.TP
Optimization
This pass only occurs if the
.B -O
option is used.
It walks through the SML array in order to find sets of redundant
instructions and replace them with a single instruction.  Whenever a
redundant set of instructions is found, the locations in the symbol
table and the flags are ajusted to point to the new instruction.
.TP
Resolve
This pass resolves any incomplete instruction.  Incomplete instructions
have only the opcode, but does not have a operand, and are flagged as
incomplete by the populate pass.  When an instruction flagged as
incomplete is found, this pass locate the symbol refered to by the flag
array and insert the memory location from the symbol into the
instruction with the unresolved reference.
.TP
Assemble
This pass walks through the SML array in order to write the
instructions to a file.  This file is ready to be executed by the
Simpletron simulator.  By default, this file is created as
.BR a.out,
but this can be changed by the
.BI "-o " outfile
option.
.SH THE SIMPLEBASIC LANGUAGE
SimpleBASIC is a simple, yet powerful, high level language similar to
early versions of the popular language BASIC.
.PP
Each line is a SimpleBASIC statement that consists of a command and its arguments.
Each command begins with one of the following keywords.
.IP
.EX
input
let
print
goto
if
end
.EE
.PP
Variable and label names are single-letter names.
SimpleBASIC does not allow descriptive variable names, so variables
should be explained in comments to indicate their use in the program.
.PP
SimpleBASIC uses only integer variables.
Simple does not have variable declarations, merely mentioning a variable
name in a program causes the variable to be declared and initialized to
zero automatically.
.PP
The syntax of SimpleBASIC does not allow string manipulation.
If a string is encountered in a SimpleBASIC command, the compiler
generates a syntax error.
.PP
SimpleBASIC uses the conditional
.B IF...,GOTO
statement and the unconditional
.B GOTO
statement to alter the flow of control during program execution.
If the condition in the
.B IF...,GOTO
statement is true, control is transferred to a specific line of the
program.
.PP
A comment in SimpleBASIC beggins with
.B ;
and go through the end of line.
.SS Labels
A label is any letter followed by a colon.
A label can occur before any SimpleBASIC statement.
Labels are used by transfer of control statements to implement flow of control and loops during process execution.
.SS SimpleBASIC commands
Commands in SimpleBASIC are case insensitive.
Both
.BR INPUT " and " input
are the same command.
.TP
.B INPUT
A input statement prompts the user to enter an integer and assign it to a variable.
Multiple variables can be input by separating them with comma.
For example, the following statement reads an integer from the keyboard
and stores it in x, then reads another integer from keyborad and stores
it in y.
.IP
.EX
INPUT x, y
.EE
.TP
.B LET
A let statement assign the value of an expression to a variable.
For example, the following statement assign
.B u
the value of
.BR "4 * (j - 56)" .
An arbitarily complex expression can appear to the right of the equal sign.
SimpleBASIC evaluates only integer expressions using the
.BR + ", " - ", " * ", " / " and " %
operators. These operators have the same precedence as in C.
Parentheses can be used to change the order of evaluation of an
expression.
.IP
.EX
LET u = 4 * (j - 56)
.EE
.TP
.B PRINT
A print statement display the value of a previously defined variable.
Multiple variables can be output by separating then with comma.
For example, the following statement display the value of w and z.
.IP
.EX
PRINT w, z
.EE
.TP
.B GOTO
A goto statement transfer program control to the statement after a specified label in the source code.
For example, the following statement transfer control to the statement after the label
.BR a .
.IP
.EX
GOTO a
.EE
.TP
.B IF ..., GOTO
A IF...,GOTO statement compare two variables and transfer program control
to the label specified after GOTO if the condition is true; otherwise,
continue execution with the next statement.  The following relational
and equality operators are valid in an
.B IF...,GOTO
statement:
.BR < ", " > ", " <= ", " >= ", " == " or " != .
For example, the following statement compare
.BR i " and " z
for equality and transfer program control to label
.B j
if they are equal.
.IP
.EX
IF i == z,  GOTO j
.EE
.TP
.B end
A end statement terminate program execution.  For example
.IP
.EX
END
.EE
.SH EXAMPLES
.SS add.basic
The following program reads two integers from the keyboard, stores the
values in variables
.BR a " and " b ,
and computes and prints their sum (stored in variable
.BR c ).
.IP
.EX
; determine and print the sum of two integers

; input two integers
INPUT a
INPUT b

; add integers and store result in c
LET c = a + b

; print the result
PRINT c

; terminate program execution
END
.EE
.SS larger.basic
The following program determines and prints the larger of two integers.
The integers are input from the keyboard and stored in
.BR s " and " t .
The
.B IF...,GOTO
statement tests the condition
.BR "s >= t" .
If the condition is true, control is transferred to label
.B a
and
.B s
is output;
otherwise,
.B t
is output and control is transferred to the
.B END
statement in label
.IP
.EX
; determine the larger of two integers

INPUT s
INPUT t

; test if s >= t
IF s >= t, GOTO a

; t is greater than s, so print t
PRINT t
GOTO b

; s is greater than or equal to t, so print s
a:
PRINT s

b:
END
.EE
.SS square.basic
SimpleBASIC does not provide a repetition structure (such as C's
.BR for ", " while " or " do...while ).
However, SimpleBASIC can simulate each of C's repetition structures
using the
.BR IF...,GOTO " and " GOTO
statements.
.PP
The following program uses a sentinel-controlled loop to calculate the squares of several integers.
Each integer is input from the keyboard and stored in variable
.BR j .
If the value entered is the sentinel
.BR +0000 ,
control is transfered to
.BR END ,
where the program terminates.
Otherwise,
.B k
is assigned the square of
.BR j ", " k
is output to the screen and control is passed to where the next integer
is input.
.IP
.EX
; Calculate the squares of several integers

a:
INPUT j

; set i as the sentinel value
LET i = +0000

; test for sentinel value
IF j == i, GOTO b

; calculate square of j and assign result to k
LET k = j * j
PRINT k

; loop to get next j
GOTO a

b:
END
.EE
.SH EXIT STATUS
.TP
.B 0
Success.
.TP
.B >0
Error occurred.
.SH HISTORY
This version of
.BR simple ,
the SimpleBASIC compiler,
is based on the exercises 12.26~12.28 from the
.B [Build Your Own Compiler]
pdf provided by Deitel.
.PP
The line label system is unique to this implementation,
since the exercise use line number system as the target of
.B GOTO
statements.
For more information, see the Wikipedia pages on
.B [Line Number]
and
.BR "[Line Label]" .
.SH CAVEATS
This version of
.B simple
only supports single-letter symbols.
In a next version, I will replace the symbol table by a binary search tree and implement multi-letter symbols.
.PP
It also does not support immediate operands for instructions.
.SH SEE ALSO
.BR simpletron (6)
.TP
.B [Build Your Own Compiler]
.B https://web.archive.org/web/20190819021934/http://www.deitel.com/bookresources/chtp8/CompilerExercises.pdf
.TP
.B [Line number]
.BR https://en.wikipedia.org/wiki/Line_number
.TP
.B [Line label]
.B https://en.wikipedia.org/wiki/Line_label
.TP
.B [Deitel & Deitel]
.BR "C: How to Program (8th edition)" ", Paul Deitel and Harvey Deitel"
