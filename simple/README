simple(6)                        Games Manual                        simple(6)



NAME
       simple - compiles SimpleBASIC into Simple Machine Language

SYNOPSIS
       simple [-O] [-o outfile] infile

DESCRIPTION
       simple compiles a source code written in a dialect of BASIC known as
       SimpleBASIC into a program in Simple Machine Language (SML) ready to be
       run by the Simpletron simulator.

       A file containing a SimpleBASIC program is read by the compiler and
       converted to SML code.  The SML code is output to a file on disk, in
       which SML instructions appear one per line.  This file is by default
       a.out, but can be set by the option -o.  The SML file can then be
       loaded into the Simpletron simulator.

       The options are as follows:

       -O     Optimize the compilation.  Makes the compiler do another pass to
              get rid of redundant instructions.

       -o outfile
              Put executable program into output file outfile.

THE SIMPLEBASIC COMPILATOR
   The symbol table
       The symbol table is a table that contains each symbol (label or
       variable) in the program and its corresponding location in the
       Simpletron's memory.  For a label, the location is the position in the
       Simpletron memory where the SML instruction generated by the
       SimpleBASIC statement begin.  For a variable, the location is the
       position in the Simpletron memory where the variable is stored.

       Each symbol (variable or label) is a single-character identifier.

   The SML array
       The SML array contains the Simpletron Machine Language (SML)
       instructions generated by the SimpleBASIC commands.  An SML instruction
       is a four-digit integer that comprises two parts: the operation code
       (opcode) and the operand.

       The opcode is determined by commands in SimpleBASIC. For example, the
       SimpleBASIC command input correspond to SML opcode 11 (write).

       The operand is a immediate value or a memory location containing the
       data on which the operation code performs its task.  For example, the
       opcode 10 (input) reads a value from keyboard and stores it in the
       memory location specified by the operand.  The compiler searchs the
       symbol table to determine the Simpletron memory location for each
       symbol so the corresponding location can be used to complete the SML
       instructions.

       Generaly, each SimpleBASIC command generates a single SML instruction.
       But compilation of if...,gotO and LET statements is more complicated
       than other statements: they are the only statements that produce more
       than one SML instruction.

       For an IF...,GOTO statement, the compiler produces code to test the
       condition and to branch to another line if necessary.  The result of
       the branch could be an unresolved reference.  Each of the relational
       and quality operators can be simulated using SML's branch zero and
       branch negative instructions (or possibly a combination of both).

       For a LET statement, the compiler produces code to evaluate an
       arbitrarily complex arithmetic expression consisting of integer
       variables and/or constants.  When a compiler encounters an expression,
       it converts the expression from infix notation to postfix notation,
       then evaluates the postfix expression.

   The flag array
       When a GOTO statement is compiled with an unresolved reference (ie', it
       refers to a location in the code that has not been read yet), the SML
       instruction must be flagged to indicate that the second pass of the
       compiler must complete the instruction.  The flags are stored in an
       array of type char in which each element is initialized to zero.  If
       the memory location to which a line number in the Simple program refers
       is not yet known (ie', it's not in the symbol table), the line number
       is stored in the flag array in the element with the same subscript as
       the incomplete instruction.  The operand of the incomplete instruction
       is set to 00 temporarily.

       For example, an unconditional branch instruction (making a forward
       reference) is left as +5000 until the resolve pass of the compiler.

   Memory size
       The Simpletron machine contains only 100 locations of memory, and a SML
       program loaded into the Simpletron's machine occupies the whole memory.
       Both data and instructions are located in memory.  The beginning of the
       memory is used to store instructions, while the end of the memory is
       used to store data.  The position of the memory where the next
       instruction and data should be placed is determined by the instruction
       counter and the the data counter, respectively.

   Counters
       It's necessary to keep track of the next instruction location in the
       SML array because there is not a one-to-one correspondence between
       SimpleBASIC statements and SML instructions.

       Each time an instruction is produced, the instruction counter is
       incremented to the next location in the SML array.

       The size of Simpletron's memory could present a problem for Simple
       programs with many statements, variables and constants.  It's
       conceivable that the compiler will run out of memory.  To test for this
       case, the program contains a data counter to keep track of the location
       at which the next variable or constant will be stored in the SML array.

       If the value of the instruction counter is larger than the data
       counter, the SML array is full.  In this case, the compilation process
       terminates and the compiler prints an error message indicating that it
       ran out of memory during compilation.

   Passes
       The compiler performs four passes (five, if optimization is set) to
       convert a SimpleBASIC program to SML.

       Initialize
              The zeroth pass initializates the compilation variables and
              arrays.  The symbol table, the SML array and the flag array are
              allocated and initialized.  The compilation counters are zeroed.

       Populate
              The first actual pass populate the symbol table with the
              variable names and label names from the source code, populate
              the SML array with instructions generated by the SimpleBASIC
              statements, and flag any instruction that is incomplete and
              needs another pass to be fully completed.

       Optimization
              This pass only occurs if the -O option is used.  It walks
              through the SML array in order to find sets of redundant
              instructions and replace them with a single instruction.
              Whenever a redundant set of instructions is found, the locations
              in the symbol table and the flags are ajusted to point to the
              new instruction.

       Resolve
              This pass resolves any incomplete instruction.  Incomplete
              instructions have only the opcode, but does not have a operand,
              and are flagged as incomplete by the populate pass.  When an
              instruction flagged as incomplete is found, this pass locate the
              symbol refered to by the flag array and insert the memory
              location from the symbol into the instruction with the
              unresolved reference.

       Assemble
              This pass walks through the SML array in order to write the
              instructions to a file.  This file is ready to be executed by
              the Simpletron simulator.  By default, this file is created as
              a.out, but this can be changed by the -o outfile option.

THE SIMPLEBASIC LANGUAGE
       SimpleBASIC is a simple, yet powerful, high level language similar to
       early versions of the popular language BASIC.

       Each line is a SimpleBASIC statement that consists of a command and its
       arguments.  Each command begins with one of the following keywords.

              input
              let
              print
              goto
              if
              end

       Variable and label names are single-letter names.  SimpleBASIC does not
       allow descriptive variable names, so variables should be explained in
       comments to indicate their use in the program.

       SimpleBASIC uses only integer variables.  Simple does not have variable
       declarations, merely mentioning a variable name in a program causes the
       variable to be declared and initialized to zero automatically.

       The syntax of SimpleBASIC does not allow string manipulation.  If a
       string is encountered in a SimpleBASIC command, the compiler generates
       a syntax error.

       SimpleBASIC uses the conditional IF...,GOTO statement and the
       unconditional GOTO statement to alter the flow of control during
       program execution.  If the condition in the IF...,GOTO statement is
       true, control is transferred to a specific line of the program.

       A comment in SimpleBASIC beggins with ; and go through the end of line.

   Labels
       A label is any letter followed by a colon.  A label can occur before
       any SimpleBASIC statement.  Labels are used by transfer of control
       statements to implement flow of control and loops during process
       execution.

   SimpleBASIC commands
       Commands in SimpleBASIC are case insensitive.  Both INPUT and input are
       the same command.

       INPUT  A input statement prompts the user to enter an integer and
              assign it to a variable.  Multiple variables can be input by
              separating them with comma.  For example, the following
              statement reads an integer from the keyboard and stores it in x,
              then reads another integer from keyborad and stores it in y.

              INPUT x, y

       LET    A let statement assign the value of an expression to a variable.
              For example, the following statement assign u the value of 4 *
              (j - 56).  An arbitarily complex expression can appear to the
              right of the equal sign.  SimpleBASIC evaluates only integer
              expressions using the +, -, *, / and % operators. These
              operators have the same precedence as in C.  Parentheses can be
              used to change the order of evaluation of an expression.

              LET u = 4 * (j - 56)

       PRINT  A print statement display the value of a previously defined
              variable.  Multiple variables can be output by separating then
              with comma.  For example, the following statement display the
              value of w and z.

              PRINT w, z

       GOTO   A goto statement transfer program control to the statement after
              a specified label in the source code.  For example, the
              following statement transfer control to the statement after the
              label a.

              GOTO a

       IF ..., GOTO
              A IF...,GOTO statement compare two variables and transfer
              program control to the label specified after GOTO if the
              condition is true; otherwise, continue execution with the next
              statement.  The following relational and equality operators are
              valid in an IF...,GOTO statement: <, >, <=, >=, == or !=.  For
              example, the following statement compare i and z for equality
              and transfer program control to label j if they are equal.

              IF i == z,  GOTO j

       end    A end statement terminate program execution.  For example

              END

EXAMPLES
   add.basic
       The following program reads two integers from the keyboard, stores the
       values in variables a and b, and computes and prints their sum (stored
       in variable c).

              ; determine and print the sum of two integers

              ; input two integers
              INPUT a
              INPUT b

              ; add integers and store result in c
              LET c = a + b

              ; print the result
              PRINT c

              ; terminate program execution
              END

   larger.basic
       The following program determines and prints the larger of two integers.
       The integers are input from the keyboard and stored in s and t.  The
       IF...,GOTO statement tests the condition s >= t.  If the condition is
       true, control is transferred to label a and s is output; otherwise, t
       is output and control is transferred to the END statement in label

              ; determine the larger of two integers

              INPUT s
              INPUT t

              ; test if s >= t
              IF s >= t, GOTO a

              ; t is greater than s, so print t
              PRINT t
              GOTO b

              ; s is greater than or equal to t, so print s
              a:
              PRINT s

              b:
              END

   square.basic
       SimpleBASIC does not provide a repetition structure (such as C's for,
       while or do...while).  However, SimpleBASIC can simulate each of C's
       repetition structures using the IF...,GOTO and GOTO statements.

       The following program uses a sentinel-controlled loop to calculate the
       squares of several integers.  Each integer is input from the keyboard
       and stored in variable j.  If the value entered is the sentinel +0000,
       control is transfered to END, where the program terminates.  Otherwise,
       k is assigned the square of j, k is output to the screen and control is
       passed to where the next integer is input.

              ; Calculate the squares of several integers

              a:
              INPUT j

              ; set i as the sentinel value
              LET i = +0000

              ; test for sentinel value
              IF j == i, GOTO b

              ; calculate square of j and assign result to k
              LET k = j * j
              PRINT k

              ; loop to get next j
              GOTO a

              b:
              END

EXIT STATUS
       0      Success.

       >0     Error occurred.

HISTORY
       This version of simple, the SimpleBASIC compiler, is based on the
       exercises 12.26~12.28 from the [Build Your Own Compiler] pdf provided
       by Deitel.

       The line label system is unique to this implementation, since the
       exercise use line number system as the target of GOTO statements.  For
       more information, see the Wikipedia pages on [Line Number] and [Line
       Label].

CAVEATS
       This version of simple only supports single-letter symbols.  In a next
       version, I will replace the symbol table by a binary search tree and
       implement multi-letter symbols.

       It also does not support immediate operands for instructions.

SEE ALSO
       simpletron(6)

       [Build Your Own Compiler]
              https://web.archive.org/web/20190819021934/http://www.deitel.com/bookresources/chtp8/CompilerExercises.pdf

       [Line number]
              https://en.wikipedia.org/wiki/Line_number

       [Line label]
              https://en.wikipedia.org/wiki/Line_label

       [Deitel & Deitel]
              C: How to Program (8th edition), Paul Deitel and Harvey Deitel



                                                                     simple(6)
